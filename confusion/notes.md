WEEK 01
*Angular is a JavaScript framework meaning that the work is handled by the framework not by ourselves
*We can modify the code to suit our needs unlike in a JS library such as React where you've to follow a specified way
*Frameworks are indeed much harder to learn than libraries
*Angular uses TypeScript/JavaScript and is component based


*ng -> angular cli 
*ng new {app name} --style=scss -> here we are creating a new angular application, setting the styles to be in SASS format
*ng serve -> startup the application

# angular follows a modular architecture where the root module (the app module) gets the help from many other helper modules, the module consists of services and components, which in turn consists of other services and components

# we aren't gonna use bootstrap cuz the javascript codes of bootstrap could conflict with our angular's javascript
# angular material module helps in layouts (similar to bootstrap) (angular material requires angular cdk and animations)
# angular uses hammarjs which provides gestures
# angular flex layout module gives us support for css flexbox

# The screen is controlled by components (basically views)

# components of angular follow a hierachy where the root component can consist of many components which in turn can consist of other components

*Our root is app component with the app component html file, which can consist of components

*np generate component menu -> generates a new component in the app module folder of the src folder

*Directives -> components, structural directives, attribute directives
*Angular templates are dynamic
*Directives give instructions to Angular on how to render the templates to the DOM
*A directive can be defined in Angular as a class with the @Directive decorator
*A component is a special kind of directive with a template associated with it (menu component and its html file)
*Strutural directives allow us to alter the layout by adding, removing and replacing elements in DOM, by applying it to a host element in the DOM and its descendents (we used *NgFor, its a structural directive)
# *NgIf (is an if condition) -> *ngIf="selectedDish"; only added if selectedDish isn't null
# NgFor (is an iterator)
# NgSwitch (is a switch case statement)



WEEK 02
*Communication between angular framework n DOM with the backend is usually used in modern web applications
*The web app will fetch data from a backend server and use the data to dynamically layout content on your website or update content on the website, so this requires the data to flow from the backend through your web application to the DOM, and any user interaction on the DOM should be conveyed back to your web application.
*This requires communication between DOM and the component.
*Data transaction and the communication between is done by angular itself
*Data binding is a mechanism for coordinating between the Template->DOM and Component->Property (Remember the data in the class of the typescript file is available in the html file) - Data flowing from component to template; events generated by user interaction flowing to the component

## One way from data source to view target
# {{ value }} - Interpolation {{dish.name}}
# [property] = 'value' 
# Property attribute 
# ex:- [dish] = 'selectedDish' || bind-dish = 'selectedDish'

## One way from view target to data source
# (event) = 'handler' || on-event = 'handler' 
# Event 
# ex:- (click) = 'onSelect(dish)' || on-click = 'onSelect(dish)'

## Two way
# [(target)] = 'value' || bindon-target = 'value'
# Two-way
# [(ngModel)] = 'dish.name'

* Binding targets are the properties that are declared on the left side of the binding declaration 
* Right side of the = are the binding sources

* Target properties must be explicitly marked as input or output properties using decorators
# @Input() dish: Dish;
# @Ouput() deleteDish = new EventEmitter<Dish>();


*A Design pattern aka an architectural pattern is a well documented solution to a recurring problem 
*Software design pattern is a reusable solution to commonly occuring problems (gang of four design patterns book)

*MVC (Model-View-Controller) Allows us to separate the domain logic from user interface whilst permitting independent development, testing and maintainance (separation of concerns)

* View - primarily concerned with presenting information to the user
# renders the model into a form suitable for interaction, typically a UI element
# Multiple views can exist for a single model for different purposes
# A viewport typically has a one to one correspondence with a display surface and knows how to render to it

* Model - stores domain state and domain logic and provides methods for manipulating the state from the rest of the app
# manages behavior and data of the application domain
# responds to requests for information about its state (usually from view)
# responds to instructions to change state (usually from controller)
# in event-driven systems, the model notifies observers (usually views) when the information changes so that they can react

* Controller -  mediates between the view and model
# receives user input and initiates a response by making calls on model object
# A controller accepts input from the user and instructs the model and viewport to perform actions based on that input


*MVVM (Model View View-Model) aka MVB (Model View-Binder) is a descendent of MVC

* View model - an abstraction of the view that exposes public properties and commands; declarative data binding

* The way how components in Angular is implemented it can be viewed as a variant of the MVVM approach


*Angular services
Why angular services?
*Component classes should be kept lean:
* Fetching data from server, user input validation and logging should be delegated to a service, these are provided by services in which the component can leverage to get work done
* Mainly act as a mediator between the view and application logic (Between view and model)

* We try to factor out application logic into services and let them do the heavy lifting (Dependency Injection;Promises; reactive JavaScript)

*Dependency Injection
* Dependency injection is a software design pattern that implements inversion of control for resolving dependencies
# Dependency: an object that can be used (a service) (Our object depends on another object)
# Injection: Passing of a dependency to a dependent object so that it can use it. The client does not need to build the object
* The object that is dependent doesn't need to know how the other object is implemented. It just need to make use of it, within your object, wherever it is

*Three ways for a component to get hold of its dependencies:
# Create dependency using new operator
# look up dependency using a global variable
# have dependency passed to it where needed
* Third is most flexible: hard coding of dependency avoided; testing becomes feasible

*Dependency Injection involves 4 roles
# The service
# The client
# The interfaces
# The injector

*Angular and DI
* Separation of business logic and dependency construction
* The dependency is passed to the object consuming it where it is needed
* Angular injector subsystem is responsible for:
# Creating components
# Resolving their dependencies
# Providing them to other components

# ng generate service services/dish -> creates a dish service in services folder

*Angular routing (works the same way as in React routing History
)
* Enables navigation among views
* Uses a browser URL as an instruction to navigate to a client-generated view, can also pass along optional parameters
* Angular uses the History API (like React) to give developers the ability to modify a website's URL without a full page refresh
# pushState() -> add history entry
# replaceState() -> Modify history entry
# Configure <base href="/">
# http://example.abc.com/home -> http://example.abc.com/menu without page reload

* Router module
* Routes {path: "/home", component: HomeComponent}

# Where the view will be rendered (will be inside the component where we wanna add components based on routing)
* routerOutlet <router-outlet></router-outlet>

# What triggers the router (like the Link tag of ReactRouter)
* routerLink <a routerLink="/menu">Menu</a>